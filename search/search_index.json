{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to reconciler's documentation! reconciler is a python package to reconcile tabular data with various reconciliation services, such as Wikidata , working similarly to what OpenRefine does, but entirely within Python, using Pandas. Quickstart You can install the latest version of reconciler from PyPI with: pip install reconciler Then to use it: from reconciler import reconcile import pandas as pd # A DataFrame with a column you want to reconcile. test_df = pd.DataFrame( { \"City\": [\"Rio de Janeiro\", \"S\u00e3o Paulo\", \"S\u00e3o Paulo\", \"Natal\"], } ) # Reconcile against type city (Q515), getting the best match for each item. reconciled = reconcile(test_df[\"City\"], type_id=\"Q515\") The resulting dataframe would look like this: id match name score type type_id input_value Q8678 True Rio de Janeiro 100 city Q515 Rio de Janeiro Q174 True S\u00e3o Paulo 100 city Q515 S\u00e3o Paulo Q131620 True Natal 100 municipality of Brazil Q3184121 Natal In case you want to ensure the results are cities from Brazil, you can specify the has_property argument with a specific property-value pair: # Reconcile against type city (Q515) and items have the country (P17) property equals to Brazil (Q155) reconciled = reconcile(test_df[\"City\"], type_id=\"Q515\", has_property=(\"P17\", \"Q155\")) Other very useful packages Although my opinion may be biased, I think reconciler is a pretty nice package. But the thing is, it probably won't fulfill all your Wikidata-related needs. Here are other packages that could help with that: WikidataIntegrator has a lot of very nice, low-level, functions for dealing with various wikidata-related activities, such as item acquisition and programmatic editing. wikidata2df is a very simple utility package for quickly and easily turning wikidata SPARQL queries into Pandas DataFrames.","title":"Home"},{"location":"#welcome-to-reconcilers-documentation","text":"reconciler is a python package to reconcile tabular data with various reconciliation services, such as Wikidata , working similarly to what OpenRefine does, but entirely within Python, using Pandas.","title":"Welcome to reconciler's documentation!"},{"location":"#quickstart","text":"You can install the latest version of reconciler from PyPI with: pip install reconciler Then to use it: from reconciler import reconcile import pandas as pd # A DataFrame with a column you want to reconcile. test_df = pd.DataFrame( { \"City\": [\"Rio de Janeiro\", \"S\u00e3o Paulo\", \"S\u00e3o Paulo\", \"Natal\"], } ) # Reconcile against type city (Q515), getting the best match for each item. reconciled = reconcile(test_df[\"City\"], type_id=\"Q515\") The resulting dataframe would look like this: id match name score type type_id input_value Q8678 True Rio de Janeiro 100 city Q515 Rio de Janeiro Q174 True S\u00e3o Paulo 100 city Q515 S\u00e3o Paulo Q131620 True Natal 100 municipality of Brazil Q3184121 Natal In case you want to ensure the results are cities from Brazil, you can specify the has_property argument with a specific property-value pair: # Reconcile against type city (Q515) and items have the country (P17) property equals to Brazil (Q155) reconciled = reconcile(test_df[\"City\"], type_id=\"Q515\", has_property=(\"P17\", \"Q155\"))","title":"Quickstart"},{"location":"#other-very-useful-packages","text":"Although my opinion may be biased, I think reconciler is a pretty nice package. But the thing is, it probably won't fulfill all your Wikidata-related needs. Here are other packages that could help with that: WikidataIntegrator has a lot of very nice, low-level, functions for dealing with various wikidata-related activities, such as item acquisition and programmatic editing. wikidata2df is a very simple utility package for quickly and easily turning wikidata SPARQL queries into Pandas DataFrames.","title":"Other very useful packages"},{"location":"authors/","text":"Development Lead Jo\u00e3o Vitor F. Cavalcante (jvfe) Contributors None yet. Why not be the first?","title":"Contributors"},{"location":"authors/#development-lead","text":"Jo\u00e3o Vitor F. Cavalcante (jvfe)","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/jvfe/reconciler/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation reconciler could always use more documentation, whether as part of the official reconciler docs, in docstrings, or even on the web in blog posts, articles, and such. To write documentation, check out the docs/ directory, and become familiar with mkdocs - it's very easy. Submit Feedback The best way to send feedback is to file an issue at https://github.com/jvfe/reconciler/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up reconciler for local development. Fork the reconciler repo on GitHub. Clone your fork locally: $ git clone git@github.com:your_name_here/reconciler.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: $ mkvirtualenv reconciler $ cd reconciler/ $ python setup.py develop Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes are black-formatted and pass the tests: $ black reconciler tests $ python setup.py test or pytest $ pytest To get black, just pip install it into your virtualenv. Add your name to the docs/authors.md file. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, if your pull request includes code changes check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and update the docs/reference files. Make sure your code changes were formatted with the Black styling tool. Tips To run a subset of tests: $ pytest tests.test_reconciler","title":"Contribution guide"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/jvfe/reconciler/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"reconciler could always use more documentation, whether as part of the official reconciler docs, in docstrings, or even on the web in blog posts, articles, and such. To write documentation, check out the docs/ directory, and become familiar with mkdocs - it's very easy.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/jvfe/reconciler/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up reconciler for local development. Fork the reconciler repo on GitHub. Clone your fork locally: $ git clone git@github.com:your_name_here/reconciler.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: $ mkvirtualenv reconciler $ cd reconciler/ $ python setup.py develop Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes are black-formatted and pass the tests: $ black reconciler tests $ python setup.py test or pytest $ pytest To get black, just pip install it into your virtualenv. Add your name to the docs/authors.md file. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, if your pull request includes code changes check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and update the docs/reference files. Make sure your code changes were formatted with the Black styling tool.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"To run a subset of tests: $ pytest tests.test_reconciler","title":"Tips"},{"location":"history/","text":"History 0.1.0 (2020-08-30) First release on PyPI. 0.1.1 (2020-09-04) Adds reconciliation_endpoint argument, so the user can define the service (Defaults to Wikidata) Changes qid_type argument to be called type_id. 0.1.2 (2020-09-24) Dataframes with more than 10 rows are now split in multiple dataframes, to avoid timeouts due to large requests. Adds a tqdm progress bar for the reconciliation. 0.1.3 (2020-09-26) Adds a new argument to the main function, has_property, which allows to reconcile against specific property-value pairs.","title":"Version history"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2020-08-30","text":"First release on PyPI.","title":"0.1.0 (2020-08-30)"},{"location":"history/#011-2020-09-04","text":"Adds reconciliation_endpoint argument, so the user can define the service (Defaults to Wikidata) Changes qid_type argument to be called type_id.","title":"0.1.1 (2020-09-04)"},{"location":"history/#012-2020-09-24","text":"Dataframes with more than 10 rows are now split in multiple dataframes, to avoid timeouts due to large requests. Adds a tqdm progress bar for the reconciliation.","title":"0.1.2 (2020-09-24)"},{"location":"history/#013-2020-09-26","text":"Adds a new argument to the main function, has_property, which allows to reconcile against specific property-value pairs.","title":"0.1.3 (2020-09-26)"},{"location":"installing/","text":"Installation Stable release To install reconciler, run this command in your terminal: $ pip install reconciler This is the preferred method to install reconciler, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From sources The sources for reconciler can be downloaded from the Github repo. You can either clone the public repository: $ git clone git://github.com/jvfe/reconciler Or download the tarball: $ curl -OJL https://github.com/jvfe/reconciler/tarball/master Once you have a copy of the source, you can install it with: $ python setup.py install","title":"Installation"},{"location":"installing/#installation","text":"","title":"Installation"},{"location":"installing/#stable-release","text":"To install reconciler, run this command in your terminal: $ pip install reconciler This is the preferred method to install reconciler, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installing/#from-sources","text":"The sources for reconciler can be downloaded from the Github repo. You can either clone the public repository: $ git clone git://github.com/jvfe/reconciler Or download the tarball: $ curl -OJL https://github.com/jvfe/reconciler/tarball/master Once you have a copy of the source, you can install it with: $ python setup.py install","title":"From sources"},{"location":"examples/reconcile_cell_types/","text":"Reconciling cell types In this showcase we'll try to reconcile some cell-type data from the Tabula muris dataset. First off, let's load the necessary packages and read in the data using Pandas. For speed and simplicity, I'll only be reconciling the unique tissue/cell_ontology_class pairs. Pre-processing from reconciler import reconcile import pandas as pd data_url = \"https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/10039264/annotations_droplets.csv\" cell_table = pd.read_csv(data_url) cell_table.head() cell tissue cell_ontology_class cell_ontology_term_iri cell_ontology_id 10X_P4_3_AAAGTAGAGATGCCAG Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACCGCGTCCAACCAA Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACTCCCGTCGGGTCT Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACTCTTAGTTGCAGG Bladder bladder cell http://purl.obolibrary.org/obo/CL_1001319 CL:1001319 10X_P4_3_AACTCTTTCATAACCG Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 Filtering only the unique pairs: unique_cells = cell_table.drop_duplicates(subset=['tissue', 'cell_ontology_class']) Reconciliation Reconciling, against cell type (Q189118), returning the first 2 matches for each item: This step will take a while to complete, varying according to your upload speed, here it took around a minute. reconciled = reconcile(unique_cells['cell_ontology_class'], type_id=\"Q189118\", top_res=2) reconciled.head(10) The output I got: id match name score type type_id input_value Q1922379 True mesenchymal stem cells 100 cell type Q189118 mesenchymal cell Q66563456 False epithelial cell of gall bladder 28 [] nan bladder cell Q66568549 False urothelial cell of trigone of urinary bladder 21 [] nan bladder cell Q11394395 False endothelial cells 50 [] nan endothelial cell Q68620792 False human sinusoidal endothelial cell 32.5 [] nan endothelial cell Q66590632 False basal cell of urothelium 50 [] nan basal cell of urothelium Q66590636 False basal cell layer of urothelium 44.5 [] nan basal cell of urothelium Q223143 False granulocyte 67 cell type Q189118 leukocyte Q1775422 False agranulocyte 60 cell type Q189118 leukocyte Q463418 True fibroblast 100 cell type Q189118 fibroblast Now if you look at the object, you will see the matches retrieved for each item. Interestingly, as of 30 Aug. 2020, there's not a lot of cell type data present in Wikidata, a lot of the matches didn't even return a \"type\" value! That means they don't even have an 'instance of' property. This could be very interesting to look into, and add this information.","title":"Reconciling cell types"},{"location":"examples/reconcile_cell_types/#reconciling-cell-types","text":"In this showcase we'll try to reconcile some cell-type data from the Tabula muris dataset. First off, let's load the necessary packages and read in the data using Pandas. For speed and simplicity, I'll only be reconciling the unique tissue/cell_ontology_class pairs.","title":"Reconciling cell types"},{"location":"examples/reconcile_cell_types/#pre-processing","text":"from reconciler import reconcile import pandas as pd data_url = \"https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/10039264/annotations_droplets.csv\" cell_table = pd.read_csv(data_url) cell_table.head() cell tissue cell_ontology_class cell_ontology_term_iri cell_ontology_id 10X_P4_3_AAAGTAGAGATGCCAG Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACCGCGTCCAACCAA Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACTCCCGTCGGGTCT Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACTCTTAGTTGCAGG Bladder bladder cell http://purl.obolibrary.org/obo/CL_1001319 CL:1001319 10X_P4_3_AACTCTTTCATAACCG Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 Filtering only the unique pairs: unique_cells = cell_table.drop_duplicates(subset=['tissue', 'cell_ontology_class'])","title":"Pre-processing"},{"location":"examples/reconcile_cell_types/#reconciliation","text":"Reconciling, against cell type (Q189118), returning the first 2 matches for each item: This step will take a while to complete, varying according to your upload speed, here it took around a minute. reconciled = reconcile(unique_cells['cell_ontology_class'], type_id=\"Q189118\", top_res=2) reconciled.head(10) The output I got: id match name score type type_id input_value Q1922379 True mesenchymal stem cells 100 cell type Q189118 mesenchymal cell Q66563456 False epithelial cell of gall bladder 28 [] nan bladder cell Q66568549 False urothelial cell of trigone of urinary bladder 21 [] nan bladder cell Q11394395 False endothelial cells 50 [] nan endothelial cell Q68620792 False human sinusoidal endothelial cell 32.5 [] nan endothelial cell Q66590632 False basal cell of urothelium 50 [] nan basal cell of urothelium Q66590636 False basal cell layer of urothelium 44.5 [] nan basal cell of urothelium Q223143 False granulocyte 67 cell type Q189118 leukocyte Q1775422 False agranulocyte 60 cell type Q189118 leukocyte Q463418 True fibroblast 100 cell type Q189118 fibroblast Now if you look at the object, you will see the matches retrieved for each item. Interestingly, as of 30 Aug. 2020, there's not a lot of cell type data present in Wikidata, a lot of the matches didn't even return a \"type\" value! That means they don't even have an 'instance of' property. This could be very interesting to look into, and add this information.","title":"Reconciliation"},{"location":"reference/reconcile/","text":"reconciler.reconcile The main module, containing the functions intended for end-users. reconcile() Reconcile a DataFrame column This is the main function of this package, it takes in a Pandas Series, that is, a column of a DataFrame, and sends it for reconciliation. In order to return more confident results, the parameter type_id corresponds to the type of item you're trying to reconcile against, that is, in case of a Wikidata item, it is the item's 'instance of' property. There is also a top_res argument, to filter the retrieved matches, this can be either an int, corresponding to the number of matches you want to retrieve for each reconciled item, or 'all', to return all matches. The has_property argument is an optional argument to denote a particular triple to reconcile against, so you could, for example, reconcile against items of a particular type, that have a specific property equals to some specific value. The reconciliation_endpoint argument corresponds to the reconciliation service you're trying to access, if no value is given, it will default to the Wikidata reconciliation endpoint. See https://reconciliation-api.github.io/testbench/ for a list of available endpoints. Parameters: Name Type Description Default column_to_reconcile Series A pandas Series corresponding to the column to be reconciled. required type_id str The item type to reconcile against, in case of a wikidata item, it corresponds to the item's 'instance of' QID. required top_res int or str The maximum number of matches to return for each reconciled item, defaults to one. To retrieve all matches, set it to 'all'. 1 has_property tuple Property-value pair of the items you want to reconcile against. For example, (\"P17\", \"Q155\") to reconcile against items that have the property country equals to Brazil. This is optional and defaults to None. None reconciliation_endpoint str The reconciliation endpoint, defaults to the Wikidata reconciliation endpoint. 'https://wikidata.reconci.link/en/api' Returns: Type Description DataFrame A Pandas DataFrame with the reconciled results. Exceptions: Type Description ValueError top_res argument must be one of either 'all' or an integer. Source code in reconciler/reconcile.py def reconcile ( column_to_reconcile , type_id , top_res = 1 , has_property = None , reconciliation_endpoint = \"https://wikidata.reconci.link/en/api\" , ): \"\"\" Reconcile a DataFrame column This is the main function of this package, it takes in a Pandas Series, that is, a column of a DataFrame, and sends it for reconciliation. In order to return more confident results, the parameter type_id corresponds to the type of item you're trying to reconcile against, that is, in case of a Wikidata item, it is the item's 'instance of' property. There is also a top_res argument, to filter the retrieved matches, this can be either an int, corresponding to the number of matches you want to retrieve for each reconciled item, or 'all', to return all matches. The has_property argument is an optional argument to denote a particular triple to reconcile against, so you could, for example, reconcile against items of a particular type, that have a specific property equals to some specific value. The reconciliation_endpoint argument corresponds to the reconciliation service you're trying to access, if no value is given, it will default to the Wikidata reconciliation endpoint. See <https://reconciliation-api.github.io/testbench/> for a list of available endpoints. Args: column_to_reconcile (Series): A pandas Series corresponding to the column to be reconciled. type_id (str): The item type to reconcile against, in case of a wikidata item, it corresponds to the item's 'instance of' QID. top_res (int or str): The maximum number of matches to return for each reconciled item, defaults to one. To retrieve all matches, set it to 'all'. has_property (tuple): Property-value pair of the items you want to reconcile against. For example, (\"P17\", \"Q155\") to reconcile against items that have the property country equals to Brazil. This is optional and defaults to None. reconciliation_endpoint (str): The reconciliation endpoint, defaults to the Wikidata reconciliation endpoint. Returns: DataFrame: A Pandas DataFrame with the reconciled results. Raises: ValueError: top_res argument must be one of either 'all' or an integer. \"\"\" size_of_frames = 10 number_of_frames = int ( len ( column_to_reconcile ) / size_of_frames ) frames = ( np . array_split ( column_to_reconcile , number_of_frames ) if len ( column_to_reconcile ) > size_of_frames else [ column_to_reconcile ] ) dfs = [] for column in tqdm ( frames , position = 0 , leave = True ): input_keys , response = return_reconciled_raw ( column , type_id , has_property , reconciliation_endpoint , ) parsed = parse_raw_results ( input_keys , response ) dfs . append ( parsed . drop ([ \"features\" ], axis = 1 )) full_df = pd . concat ( dfs ) if top_res == \"all\" : return full_df elif isinstance ( top_res , int ): filtered = full_df . groupby ( \"input_value\" ) . head ( top_res ) . reset_index ( drop = True ) return filtered else : raise ValueError ( \"top_res argument must be one of either 'all' or an integer\" )","title":"Main module"},{"location":"reference/reconcile/#reconcilerreconcile","text":"The main module, containing the functions intended for end-users. reconcile()","title":"reconciler.reconcile"},{"location":"reference/reconcile/#reconciler.reconcile.reconcile","text":"Reconcile a DataFrame column This is the main function of this package, it takes in a Pandas Series, that is, a column of a DataFrame, and sends it for reconciliation. In order to return more confident results, the parameter type_id corresponds to the type of item you're trying to reconcile against, that is, in case of a Wikidata item, it is the item's 'instance of' property. There is also a top_res argument, to filter the retrieved matches, this can be either an int, corresponding to the number of matches you want to retrieve for each reconciled item, or 'all', to return all matches. The has_property argument is an optional argument to denote a particular triple to reconcile against, so you could, for example, reconcile against items of a particular type, that have a specific property equals to some specific value. The reconciliation_endpoint argument corresponds to the reconciliation service you're trying to access, if no value is given, it will default to the Wikidata reconciliation endpoint. See https://reconciliation-api.github.io/testbench/ for a list of available endpoints. Parameters: Name Type Description Default column_to_reconcile Series A pandas Series corresponding to the column to be reconciled. required type_id str The item type to reconcile against, in case of a wikidata item, it corresponds to the item's 'instance of' QID. required top_res int or str The maximum number of matches to return for each reconciled item, defaults to one. To retrieve all matches, set it to 'all'. 1 has_property tuple Property-value pair of the items you want to reconcile against. For example, (\"P17\", \"Q155\") to reconcile against items that have the property country equals to Brazil. This is optional and defaults to None. None reconciliation_endpoint str The reconciliation endpoint, defaults to the Wikidata reconciliation endpoint. 'https://wikidata.reconci.link/en/api' Returns: Type Description DataFrame A Pandas DataFrame with the reconciled results. Exceptions: Type Description ValueError top_res argument must be one of either 'all' or an integer. Source code in reconciler/reconcile.py def reconcile ( column_to_reconcile , type_id , top_res = 1 , has_property = None , reconciliation_endpoint = \"https://wikidata.reconci.link/en/api\" , ): \"\"\" Reconcile a DataFrame column This is the main function of this package, it takes in a Pandas Series, that is, a column of a DataFrame, and sends it for reconciliation. In order to return more confident results, the parameter type_id corresponds to the type of item you're trying to reconcile against, that is, in case of a Wikidata item, it is the item's 'instance of' property. There is also a top_res argument, to filter the retrieved matches, this can be either an int, corresponding to the number of matches you want to retrieve for each reconciled item, or 'all', to return all matches. The has_property argument is an optional argument to denote a particular triple to reconcile against, so you could, for example, reconcile against items of a particular type, that have a specific property equals to some specific value. The reconciliation_endpoint argument corresponds to the reconciliation service you're trying to access, if no value is given, it will default to the Wikidata reconciliation endpoint. See <https://reconciliation-api.github.io/testbench/> for a list of available endpoints. Args: column_to_reconcile (Series): A pandas Series corresponding to the column to be reconciled. type_id (str): The item type to reconcile against, in case of a wikidata item, it corresponds to the item's 'instance of' QID. top_res (int or str): The maximum number of matches to return for each reconciled item, defaults to one. To retrieve all matches, set it to 'all'. has_property (tuple): Property-value pair of the items you want to reconcile against. For example, (\"P17\", \"Q155\") to reconcile against items that have the property country equals to Brazil. This is optional and defaults to None. reconciliation_endpoint (str): The reconciliation endpoint, defaults to the Wikidata reconciliation endpoint. Returns: DataFrame: A Pandas DataFrame with the reconciled results. Raises: ValueError: top_res argument must be one of either 'all' or an integer. \"\"\" size_of_frames = 10 number_of_frames = int ( len ( column_to_reconcile ) / size_of_frames ) frames = ( np . array_split ( column_to_reconcile , number_of_frames ) if len ( column_to_reconcile ) > size_of_frames else [ column_to_reconcile ] ) dfs = [] for column in tqdm ( frames , position = 0 , leave = True ): input_keys , response = return_reconciled_raw ( column , type_id , has_property , reconciliation_endpoint , ) parsed = parse_raw_results ( input_keys , response ) dfs . append ( parsed . drop ([ \"features\" ], axis = 1 )) full_df = pd . concat ( dfs ) if top_res == \"all\" : return full_df elif isinstance ( top_res , int ): filtered = full_df . groupby ( \"input_value\" ) . head ( top_res ) . reset_index ( drop = True ) return filtered else : raise ValueError ( \"top_res argument must be one of either 'all' or an integer\" )","title":"reconciler.reconcile.reconcile"},{"location":"reference/webutils/","text":"reconciler.webutils The utilities module, for formatting and performing queries. get_query_dict() Convert a pandas DataFrame column to a query dictionary The reconciliation API requires a json request formatted in a very particular way. This function takes in a DataFrame column and reformats it. Parameters: Name Type Description Default df_column Series A pandas Series to reconcile. required type_id str A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. required Returns: Type Description tuple A tuple containing the list of the original values sent to reconciliation a dictionary with the column values reformatted. Source code in reconciler/webutils.py def get_query_dict ( df_column , type_id , has_property ): \"\"\" Convert a pandas DataFrame column to a query dictionary The reconciliation API requires a json request formatted in a very particular way. This function takes in a DataFrame column and reformats it. Args: df_column (Series): A pandas Series to reconcile. type_id (str): A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. Returns: tuple: A tuple containing the list of the original values sent to reconciliation a dictionary with the column values reformatted. \"\"\" input_keys = df_column . unique () reformatted = defaultdict ( dict ) for idx , value in enumerate ( input_keys ): if has_property is None : reformatted [ idx ] = { \"query\" : value , \"type\" : type_id } else : reformatted [ idx ] = { \"query\" : value , \"type\" : type_id , \"properties\" : [{ \"pid\" : has_property [ 0 ], \"v\" : { \"id\" : has_property [ 1 ]}}], } return input_keys , reformatted perform_query() Make a post request to the reconciliation API Parameters: Name Type Description Default query_string str A string corresponding to the query JSON. required reconciliation_endpoint str A url to the reconciliation endpoint. required Returns: Type Description dict A dictionary (JSON) with the query results. Exceptions: Type Description requests.HTTPError The query returned an error, check if you mistyped an argument. requests.ConnectionError Couldn't connect to reconciliation client. Source code in reconciler/webutils.py @lru_cache ( maxsize = None ) def perform_query ( query_string , reconciliation_endpoint ): \"\"\"Make a post request to the reconciliation API Args: query_string (str): A string corresponding to the query JSON. reconciliation_endpoint (str): A url to the reconciliation endpoint. Returns: dict: A dictionary (JSON) with the query results. Raises: requests.HTTPError: The query returned an error, check if you mistyped an argument. requests.ConnectionError: Couldn't connect to reconciliation client. \"\"\" tries = 0 while tries < 3 : try : response = requests . post ( reconciliation_endpoint , data = json . loads ( query_string ) ) except requests . ConnectionError : tries += 1 else : query_result = response . json () if \"status\" in query_result and query_result [ \"status\" ] == \"error\" : raise requests . HTTPError ( \"The query returned an error, check if you mistyped an argument.\" ) else : return query_result if tries == 3 : raise requests . ConnectionError ( \"Couldn't connect to reconciliation client\" ) return_reconciled_raw() Send reformatted dict for reconciliation This is just a wrapper around the other utility functions. The only thing it actually does is convert the query dict to an appropriate JSON string. Parameters: Name Type Description Default df_column Series A pandas Series to reconcile. required type_id str A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. required reconciliation_endpoint str A url to the reconciliation endpoint. required Returns: Type Description tuple A tuple containing the list of the original values sent to reconciliation and a dictionary (JSON) with the query results. Source code in reconciler/webutils.py def return_reconciled_raw ( df_column , type_id , has_property , reconciliation_endpoint ): \"\"\"Send reformatted dict for reconciliation This is just a wrapper around the other utility functions. The only thing it actually does is convert the query dict to an appropriate JSON string. Args: df_column (Series): A pandas Series to reconcile. type_id (str): A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. reconciliation_endpoint (str): A url to the reconciliation endpoint. Returns: tuple: A tuple containing the list of the original values sent to reconciliation and a dictionary (JSON) with the query results. \"\"\" input_keys , reformatted = get_query_dict ( df_column , type_id , has_property ) reconcilable_data = json . dumps ({ \"queries\" : json . dumps ( reformatted )}) query_result = perform_query ( reconcilable_data , reconciliation_endpoint ) return input_keys , query_result parse_raw_results() Parse JSON query result Parameters: Name Type Description Default input_keys list A list with the original input values that were used to reconcile. required response dict A dict corresponding to the raw JSON response from the reconciliation API. required Returns: Type Description DataFrame A Pandas DataFrame with all the results. Source code in reconciler/webutils.py def parse_raw_results ( input_keys , response ): \"\"\" Parse JSON query result Args: input_keys (list): A list with the original input values that were used to reconcile. response (dict): A dict corresponding to the raw JSON response from the reconciliation API. Returns: DataFrame: A Pandas DataFrame with all the results. \"\"\" res_keys = sorted ( response . keys (), key = int ) dfs = [] for idx , key in enumerate ( res_keys ): current_df = pd . json_normalize ( response [ key ][ \"result\" ]) if current_df . empty : current_df = pd . DataFrame ( { \"id\" : [ np . NaN ], \"match\" : [ False ], } ) else : try : current_df [ \"type_id\" ] = [ item [ 0 ][ \"id\" ] for item in current_df [ \"type\" ]] current_df [ \"type\" ] = [ item [ 0 ][ \"name\" ] for item in current_df [ \"type\" ]] except IndexError : pass current_df [ \"input_value\" ] = input_keys [ idx ] dfs . append ( current_df ) concatenated = pd . concat ( dfs ) return concatenated","title":"Utility module"},{"location":"reference/webutils/#reconcilerwebutils","text":"The utilities module, for formatting and performing queries. get_query_dict()","title":"reconciler.webutils"},{"location":"reference/webutils/#reconciler.webutils.get_query_dict","text":"Convert a pandas DataFrame column to a query dictionary The reconciliation API requires a json request formatted in a very particular way. This function takes in a DataFrame column and reformats it. Parameters: Name Type Description Default df_column Series A pandas Series to reconcile. required type_id str A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. required Returns: Type Description tuple A tuple containing the list of the original values sent to reconciliation a dictionary with the column values reformatted. Source code in reconciler/webutils.py def get_query_dict ( df_column , type_id , has_property ): \"\"\" Convert a pandas DataFrame column to a query dictionary The reconciliation API requires a json request formatted in a very particular way. This function takes in a DataFrame column and reformats it. Args: df_column (Series): A pandas Series to reconcile. type_id (str): A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. Returns: tuple: A tuple containing the list of the original values sent to reconciliation a dictionary with the column values reformatted. \"\"\" input_keys = df_column . unique () reformatted = defaultdict ( dict ) for idx , value in enumerate ( input_keys ): if has_property is None : reformatted [ idx ] = { \"query\" : value , \"type\" : type_id } else : reformatted [ idx ] = { \"query\" : value , \"type\" : type_id , \"properties\" : [{ \"pid\" : has_property [ 0 ], \"v\" : { \"id\" : has_property [ 1 ]}}], } return input_keys , reformatted perform_query()","title":"reconciler.webutils.get_query_dict"},{"location":"reference/webutils/#reconciler.webutils.perform_query","text":"Make a post request to the reconciliation API Parameters: Name Type Description Default query_string str A string corresponding to the query JSON. required reconciliation_endpoint str A url to the reconciliation endpoint. required Returns: Type Description dict A dictionary (JSON) with the query results. Exceptions: Type Description requests.HTTPError The query returned an error, check if you mistyped an argument. requests.ConnectionError Couldn't connect to reconciliation client. Source code in reconciler/webutils.py @lru_cache ( maxsize = None ) def perform_query ( query_string , reconciliation_endpoint ): \"\"\"Make a post request to the reconciliation API Args: query_string (str): A string corresponding to the query JSON. reconciliation_endpoint (str): A url to the reconciliation endpoint. Returns: dict: A dictionary (JSON) with the query results. Raises: requests.HTTPError: The query returned an error, check if you mistyped an argument. requests.ConnectionError: Couldn't connect to reconciliation client. \"\"\" tries = 0 while tries < 3 : try : response = requests . post ( reconciliation_endpoint , data = json . loads ( query_string ) ) except requests . ConnectionError : tries += 1 else : query_result = response . json () if \"status\" in query_result and query_result [ \"status\" ] == \"error\" : raise requests . HTTPError ( \"The query returned an error, check if you mistyped an argument.\" ) else : return query_result if tries == 3 : raise requests . ConnectionError ( \"Couldn't connect to reconciliation client\" ) return_reconciled_raw()","title":"reconciler.webutils.perform_query"},{"location":"reference/webutils/#reconciler.webutils.return_reconciled_raw","text":"Send reformatted dict for reconciliation This is just a wrapper around the other utility functions. The only thing it actually does is convert the query dict to an appropriate JSON string. Parameters: Name Type Description Default df_column Series A pandas Series to reconcile. required type_id str A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. required reconciliation_endpoint str A url to the reconciliation endpoint. required Returns: Type Description tuple A tuple containing the list of the original values sent to reconciliation and a dictionary (JSON) with the query results. Source code in reconciler/webutils.py def return_reconciled_raw ( df_column , type_id , has_property , reconciliation_endpoint ): \"\"\"Send reformatted dict for reconciliation This is just a wrapper around the other utility functions. The only thing it actually does is convert the query dict to an appropriate JSON string. Args: df_column (Series): A pandas Series to reconcile. type_id (str): A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item. reconciliation_endpoint (str): A url to the reconciliation endpoint. Returns: tuple: A tuple containing the list of the original values sent to reconciliation and a dictionary (JSON) with the query results. \"\"\" input_keys , reformatted = get_query_dict ( df_column , type_id , has_property ) reconcilable_data = json . dumps ({ \"queries\" : json . dumps ( reformatted )}) query_result = perform_query ( reconcilable_data , reconciliation_endpoint ) return input_keys , query_result parse_raw_results()","title":"reconciler.webutils.return_reconciled_raw"},{"location":"reference/webutils/#reconciler.webutils.parse_raw_results","text":"Parse JSON query result Parameters: Name Type Description Default input_keys list A list with the original input values that were used to reconcile. required response dict A dict corresponding to the raw JSON response from the reconciliation API. required Returns: Type Description DataFrame A Pandas DataFrame with all the results. Source code in reconciler/webutils.py def parse_raw_results ( input_keys , response ): \"\"\" Parse JSON query result Args: input_keys (list): A list with the original input values that were used to reconcile. response (dict): A dict corresponding to the raw JSON response from the reconciliation API. Returns: DataFrame: A Pandas DataFrame with all the results. \"\"\" res_keys = sorted ( response . keys (), key = int ) dfs = [] for idx , key in enumerate ( res_keys ): current_df = pd . json_normalize ( response [ key ][ \"result\" ]) if current_df . empty : current_df = pd . DataFrame ( { \"id\" : [ np . NaN ], \"match\" : [ False ], } ) else : try : current_df [ \"type_id\" ] = [ item [ 0 ][ \"id\" ] for item in current_df [ \"type\" ]] current_df [ \"type\" ] = [ item [ 0 ][ \"name\" ] for item in current_df [ \"type\" ]] except IndexError : pass current_df [ \"input_value\" ] = input_keys [ idx ] dfs . append ( current_df ) concatenated = pd . concat ( dfs ) return concatenated","title":"reconciler.webutils.parse_raw_results"}]}